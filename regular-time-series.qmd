---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Regular time series

If a time series is "regular", that is it has equal time steps between observations, and no missing observations, then its power spectrum can be estimated from its Fourier transform. 


## The Fourier Transform

Here we will use the Fast Fourier Transform function in base R to calculate the periodogram ourselves from the Fourier transform of a time series, just to see how it is done.


```{r}
sunspot <- datasets::sunspot.month
plot(sunspot)
```

```{r}
fft_sun <- fft(as.numeric(sunspot))
str(fft_sun)
```

`fft` returns a vector of complex numbers corresponding to the magnitude and phase of variation at a set of 'Fourier' frequencies. To obtain the periodogram we take the square of the absolute value of these complex numbers, discarding the complex part containing the phase information.

```{r}
# Delta t, the time interval between observations, here 1 month, so 1/12 of a year
delta_t <- 1/12
spec <- abs(fft_sun)^2 * (delta_t/length(sunspot))
```

Typically, we are only interested in the positive Fourier frequencies, which run from the lowest resolved positive frequency 1 / (delta_t * N), where N is the length of the timeseries, up to the highest resolved frequency, the Nyquist frequency 1/(2 * delta_t), with the distance between frequencies, delta_f, also equal to 1/(delta_t * N). 

However, the Fourier transform also returns values for the 'zeroth' frequency, and for a set of negative frequencies. For a transform of a time series of real numbers, the values at the negative frequencies are identical to the positive frequencies, so they contain no additional information.

Here we will once plot the negative, zeroth, and positive frequencies together, but later we will only consider the positive frequencies.


```{r}
library(dplyr)
library(PaleoSpec)
library(ggplot2)

N <- length(sunspot)

pos_freq <- seq(1 / (delta_t * N), 1/(2*delta_t), by = 1 / (delta_t * N))

freq <- c(0, pos_freq, -rev(pos_freq))

spec_sun <- tibble(
  freq = freq,
  spec = spec,
  dof = 2
) %>% 
  arrange(desc(freq))

plot(spec~freq, data = spec_sun, type = "l", log = "y")
```


Now we will discard all frequencies less than and equal to zero and re-plot on log-log axes. We will also compare our result to R's built in function to estimate periodograms. 

```{r}
spec_sun_fft <- spec_sun %>% 
  filter(freq > 0) %>% 
  PaleoSpec::as.spec()

spec_sun_pgram <- spec.pgram(sunspots, plot = FALSE)
spec_sun_pgram$dof <- spec_sun_pgram$df

gg_spec(list(
  pgram = spec_sun_pgram,
  fft = spec_sun)
  ) +
  geom_vline(xintercept = 1/11)


gg_spec(list(
  pgram = FilterSpecLog(spec_sun_pgram, df.log = 0.01),
  fft = FilterSpecLog(spec_sun_fft, df.log = 0.01))
  ) +
  geom_vline(xintercept = 1/c(11, 5.5))


glm1 <- glm(spec ~ log(freq), family = Gamma(link = "log"), data = Spec2DF(spec_sun_fft))

gg_spec(FilterSpec(spec_sun_fft, spans = c(3, 5, 7))) +
  geom_abline(intercept = log(coef(glm1)[1]), slope = coef(glm1)[2], col = "red")

```




## The Multitaper Method

```{r}
library(PaleoSpec)
sp_sun <- SpecMTM(sunspot)
LPlot(sp_sun)
```


## To detrend or not {#sec-detrend}


### Why detrend?



```{r}
library(dplyr)
library(tidyr)
library(PaleoSpec)
library(ggplot2)

f1 <- 1/10
f2 <- 1/100
f3 <- 1/1000

tau <- 1e04

#tau / (1/c(f1, f2, f3))

dat <- tibble(
  time = seq(0, tau, by = 1),
  y = cos(2*pi*f1*time) + cos(2*pi*f2*time) + cos(2*pi*f3*time) 
) %>% 
  mutate(y = y + rnorm(n(), 0, 0.1))

plot(dat$time, dat$y, type = "l")


sp1 <- SpecMTM(ts(dat$y, deltat = 1), detrend =  FALSE)
sp1_detr <- SpecMTM(ts(dat$y, deltat = 1), detrend =  TRUE)

#sp1 <- SpecACF(ts(dat$y, deltat = 1), bin.width = 1, detrend =  FALSE)


gg_spec(list(sp1, detrended = sp1_detr)) +
  geom_vline(xintercept = c(f1, f2, f3), lty = 2, colour =  "Red")



sp1_10k <- SpecACF(ts(dat$y, deltat = 1), bin.width = 1, detrend =  FALSE)
sp1_10k_detr <- SpecACF(ts(dat$y, deltat = 1), bin.width = 1, detrend =  TRUE)

plot(y~time, data = dat[1:500,],  type = "l")

sp1_0.5k <- SpecACF(ts(dat$y[1:500], deltat = 1), bin.width = 1, detrend =  FALSE)
sp1_0.5k_detr <- SpecACF(ts(dat$y[1:500], deltat = 1), bin.width = 1, detrend =  TRUE)


sp1_0.5k_detr_MTM <- SpecMTM(ts(dat$y[1:500], deltat = 1), detrend =  TRUE)


list(
  raw_10k = (sp1_10k),
  detrended_10k = (sp1_10k_detr),
  raw_0.5k = (sp1_0.5k), 
  detrended_0.5k = (sp1_0.5k_detr)
  #detrended_0.5k_MTM = (sp1_0.5k_detr_MTM)
  ) %>% 
  lapply(., Spec2DF) %>% 
  bind_rows(., .id = "name") %>% 
  separate(name, into = c("detrended", "length"), sep = "_") %>% 
  mutate(spec_id = detrended) %>% 
  as_spec_df() %>% 
  gg_spec(., colour = detrended) +
  facet_wrap(~length)#+
  #geom_vline(xintercept = c(f1, f2, f3), lty = 2, colour =  "blue")


```



- Even with detrend = FALSE, SpecMTM does some detrending - must be part of the tapering?



```{r}
library(dplyr)
library(tidyr)
library(PaleoSpec)
library(ggplot2)


N <- 1e03
n_rep <- 1000
alpha = 0.1
beta = 0

dat <- crossing(
  rep = 1:n_rep,
  t = 1:N
) #%>% 
  # group_by(rep) %>% 
  # mutate(
  #   y = PaleoSpec::SimPLS(N = N, beta = beta, alpha = alpha) 
  # )

# Get a matrix of simulated timeseries
ts_m <- replicate(n_rep, PaleoSpec::SimPLS(N = N, beta = beta, alpha = alpha))

mean_spec <- SpecACF(ts_m, bin.width = 1, detrend = FALSE)
mean_spec_detrended <- SpecACF(ts_m, bin.width = 1)

dat$y <- as.numeric(ts_m)

specs_mtm_detrend <- dat %>% 
  group_by(rep) %>% 
  do({
    Spec2DF(SpecMTM(ts(.$y), 
                    detrend = TRUE
                    )
            )
  })

specs_mtm_raw <- dat %>% 
  group_by(rep) %>% 
  do({
    Spec2DF(SpecMTM(ts(.$y), 
                    detrend = FALSE
                    )
            )
  })


mean_spec_MTM_raw <- specs_mtm_raw %>% 
  group_by(freq) %>% 
  summarise_if(is.numeric, mean)

mean_spec_MTM_detrended <- specs_mtm_detrend %>% 
  group_by(freq) %>% 
  summarise_if(is.numeric, mean)

gg_spec(list("Periodogram_raw_ts" = mean_spec,
             "Periodogram_detrended_ts" = mean_spec_detrended,
             MTM_detrended = mean_spec_MTM_detrended,
             MTM_raw_ts = mean_spec_MTM_raw)) #+
  #geom_point(aes(x = freq, y = spec, colour = spec_id))
```




## Errors

- Explain Gamma / Chi-Sq nature of the errors
- Degrees of freedom / shape of Gamma
- Effect of tapering and smoothing on error distribution
- Confidence intervals

