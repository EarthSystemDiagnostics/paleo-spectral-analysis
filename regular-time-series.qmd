---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Regular time series

If a time series is "regular", that is it has equal time steps between observations, and no missing observations, then its power spectrum can be estimated from its Fourier transform. 


## The Fourier Transform

In this section we will avoid using any of the specialist functions provided by PaleoSpec, we will use the Fast Fourier Transform function in base R to calculate the periodogram ourselves from the Fourier transform of a time series, just to see how it is done. 


We will look at the power spectrum of the monthly numbers of sunspots in the `sunspots.monthly` dataset in the `datasets` package that comes with a default R installation.


```{r}
sunspot <- datasets::sunspot.month
plot(sunspot)
```

The data are documented in a help file.

```{r, eval=FALSE}
?datasets::sunspot.month
```



```{r}
fft_sun <- fft(as.numeric(sunspot))
str(fft_sun)
```

`fft` returns a vector of complex numbers corresponding to the magnitude and phase of variation at a set of 'Fourier' frequencies. To obtain the periodogram we take the square of the absolute value of these complex numbers, discarding the imaginary part containing the phase information.

```{r}
# Delta t, the time interval between observations, here 1 month, 
# so 1/12 of a year
N <- length(sunspot)
delta_t <- 1/12
spec <- abs(fft_sun)^2 * (delta_t/N)
```

Typically, we are only interested in the positive Fourier frequencies, which run from the lowest resolved positive frequency 1 / (delta_t * N), where N is the length of the timeseries, up to the highest resolved frequency, the Nyquist frequency 1/(2 * delta_t), with the distance between frequencies, delta_f, also equal to 1/(delta_t * N). 
```{r}
pos_freq <- seq(1 / (delta_t * N), 1/(2*delta_t), by = 1 / (delta_t * N))
```


However, the Fourier transform also returns values for the 'zeroth' frequency, and for a set of negative frequencies. For a transform of a time series of real numbers, the values at the negative frequencies are identical to the positive frequencies, so they contain no additional information.

Here we will once plot the negative, zeroth, and positive frequencies together; later we will only consider the positive frequencies.

```{r}
freq <- c(0, pos_freq, -rev(pos_freq))

spec_sun <- data.frame(
  freq = freq,
  spec = spec
) 

# re-order by frequency to make the plot neater
spec_sun <- spec_sun[order(spec_sun$freq), ]

plot(spec~freq, data = spec_sun, type = "l", log = "y")
```


Now we will discard all frequencies less than and equal to zero and re-plot on log-log axes. We will also compare our result to R's built in function to estimate periodograms. 

```{r}
spec_sun_fft <- subset(spec_sun, freq > 0) 

spec_sun_pgram <- spec.pgram(sunspots, plot = FALSE)

plot(spec~freq, data = spec_sun_fft, type = "l", log = "xy", col = "blue")
# the output from spec.pgram is a list not a dataframe
lines(spec_sun_pgram$freq, spec_sun_pgram$spec, col = "green")
abline(v = 1/11)
legend("topright", legend = c("fft", "pgram"), col = c("blue", "green"), lty = c(1,1))
```




## The Multitaper Method

```{r}
library(PaleoSpec)
sp_sun <- SpecMTM(sunspot)
LPlot(spec_sun_fft, col = "blue")
LLines(spec_sun_pgram, col = "green")
LLines(sp_sun, col = "red")
legend("topright", legend = c("fft", "pgram", "MTM"), col = c("blue", "green", "red"), lty = c(1,1, 1))
```


## To detrend or not {#sec-detrend}


### Why detrend?

```{r}
library(dplyr)
library(tidyr)
library(PaleoSpec)
library(ggplot2)

f1 <- 1/10
f2 <- 1/100
f3 <- 1/1000

tau <- 1e04

#tau / (1/c(f1, f2, f3))

dat <- tibble(
  time = seq(0, tau, by = 1),
  y = cos(2*pi*f1*time) + cos(2*pi*f2*time) + cos(2*pi*f3*time) 
) %>% 
  mutate(y = y + rnorm(n(), 0, 0.1))

plot(dat$time, dat$y, type = "l")
```


```{r}
sp1_10k <- SpecACF(ts(dat$y, deltat = 1), bin.width = 1, detrend =  FALSE)
sp1_10k_detr <- SpecACF(ts(dat$y, deltat = 1), bin.width = 1, detrend =  TRUE)

gg_spec(list(raw = sp1_10k, detrended = sp1_10k_detr)) +
  geom_vline(xintercept = c(f1, f2, f3), lty = 2, colour =  "Red")
```


```{r}
dat_500 <- dat[1:500,]
plot(y~time, data = dat_500,  type = "l")
```


```{r}
sp1_0.5k <- SpecACF(ts(dat_500$y, deltat = 1), bin.width = 1, detrend =  FALSE)
sp1_0.5k_detr <- SpecACF(ts(dat_500$y, deltat = 1), bin.width = 1, detrend =  TRUE)

list(
  raw_10k = (sp1_10k),
  detrended_10k = (sp1_10k_detr),
  raw_0.5k = (sp1_0.5k), 
  detrended_0.5k = (sp1_0.5k_detr)
  ) %>% 
  lapply(., Spec2DF) %>% 
  bind_rows(., .id = "name") %>% 
  separate(name, into = c("detrended", "ts_length"), sep = "_") %>% 
  mutate(spec_id = detrended) %>% 
  as_spec_df() %>% 
  gg_spec(., colour = detrended) +
  facet_wrap(~ts_length, labeller = label_both)#+
  #geom_vline(xintercept = c(f1, f2, f3), lty = 2, colour =  "blue")
```


Fit and remove something closer to a spline

```{r}
lm_ns1 <- lm(y ~ splines::ns(time,3), data = dat_500)

# fit.nls <- nls(y~C+alpha*sin(W*time+phi), data = dat_500,
#                 start=list(C=27.63415, alpha=27.886, W=f3*2*pi, phi = 14))
# 
# dat_500$fttd_sine_nls <- fitted(fit.nls)
# dat_500$res_sine_nls <- as.numeric(residuals(fit.nls))

dat_500$fttd_sine <- fitted(lm_ns1)
dat_500$res_sine <- residuals(lm_ns1)


plot(y~time, data = dat_500, type = "l")
lines(fttd_sine~time, data = dat_500, col = "green")
#lines(fttd_sine_nls~time, data = dat_500, col = "red")
```


```{r}
#plot(res_sine~time, data = dat_500, type = "l")

sp1_res <- SpecACF(dat_500$res_sine, bin.width = 1)

gg_spec(list(
  spline_detrend = sp1_res, raw = sp1_0.5k, linear_detrend = sp1_0.5k_detr, full = sp1_10k
))
```




- Even with detrend = FALSE, SpecMTM does some detrending - must be part of the tapering?



```{r}
library(dplyr)
library(tidyr)
library(PaleoSpec)
library(ggplot2)

N <- 1e03
n_rep <- 1000
alpha = 0.1
beta = 0

dat <- crossing(
  rep = 1:n_rep,
  t = 1:N
) 


# Get a matrix of simulated timeseries
ts_m <- replicate(n_rep, PaleoSpec::SimPLS(N = N, beta = beta, alpha = alpha))

mean_spec <- SpecACF(ts_m, bin.width = 1, detrend = FALSE)
mean_spec_detrended <- SpecACF(ts_m, bin.width = 1)

dat$y <- as.numeric(ts_m)

specs_mtm_detrend <- dat %>% 
  group_by(rep) %>% 
  do({
    Spec2DF(SpecMTM(ts(.$y), 
                    detrend = TRUE
                    )
            )
  })

specs_mtm_raw <- dat %>% 
  group_by(rep) %>% 
  do({
    Spec2DF(SpecMTM(ts(.$y), 
                    detrend = FALSE
                    )
            )
  })


mean_spec_MTM_raw <- specs_mtm_raw %>% 
  group_by(freq) %>% 
  summarise_if(is.numeric, mean)

mean_spec_MTM_detrended <- specs_mtm_detrend %>% 
  group_by(freq) %>% 
  summarise_if(is.numeric, mean)

gg_spec(list("Periodogram_raw_ts" = mean_spec,
             "Periodogram_detrended_ts" = mean_spec_detrended,
             MTM_detrended = mean_spec_MTM_detrended,
             MTM_raw_ts = mean_spec_MTM_raw)) #+
  #geom_point(aes(x = freq, y = spec, colour = spec_id))
```




```{r}
## Significance of peaks

# gg_spec(list(
#   pgram = FilterSpecLog(spec_sun_pgram, df.log = 0.01),
#   fft = FilterSpecLog(spec_sun_fft, df.log = 0.01))
#   ) +
#   geom_vline(xintercept = 1/c(11, 5.5))
# 
# 
# glm1 <- glm(spec ~ log(freq), family = Gamma(link = "log"), data = Spec2DF(spec_sun_fft))
# 
# gg_spec(FilterSpec(spec_sun_fft, spans = c(3, 5, 7))) +
#   geom_abline(intercept = log(coef(glm1)[1]), slope = coef(glm1)[2], col = "red")
```

```{r}
## Value at f = 0 is the mean
# abs(fft_sun[1]) / length(sunspot)
# sqrt(spec[1] * N/delta_t) / length(sunspot)
# mean(sunspot)

# must remove mean if padding or you will get spectral leakage from freq zero
```



## Errors

- Explain Gamma / Chi-Sq nature of the errors
- Degrees of freedom / shape of Gamma
- Effect of tapering and smoothing on error distribution
- Confidence intervals

